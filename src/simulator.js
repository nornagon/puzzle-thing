// Generated by CoffeeScript 2.2.4
// This is the reference implementation for the boilerplate turing tarpit. This
// implementation is horrendously slow - it floodfills from every engine on
// every tick.

// The world is an infinite space stored in a javascript object as world["<x>,<y>"] = value.

// For example, world = {"10,20": "negative", "10,21": "shuttle"}
// Empty world values (null or undefined) are solid tiles. Coordinates can be
// negative (the space is infinite in all directions).

// Possible tile values are

// - positive: Positive pressure pump
// - negative: Negative pressure pump
// - nothing: Empty space
// - thinsolid: Solid rock which lets air pass (aka a grill / grate)
// - shuttle: Part of a shuttle - gets pushed by pressure
// - thinshuttle: Part of a shuttle which allows air to pass it
// - bridge: Equivalent to 'nothing' - allows pressure to pass horizontally and
//   vertially, without interference
// - null / undefined: Solid rock. No pressure / movement possible.

// This implementation welds shuttles which touch - I declare this to be (in
// general) undefined behaviour, because its inconvenient behaviour in a
// compiled implementation.
debugger;
var Simulator, cardinal_dirs, fill, parseXY, sign;

cardinal_dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];

fill = function(initial_square, f) {
  var hmm, n, ok, to_explore, visited;
  visited = {};
  visited[`${initial_square.x},${initial_square.y}`] = true;
  to_explore = [initial_square];
  hmm = function(x, y) {
    var k;
    k = `${x},${y}`;
    if (!visited[k]) {
      visited[k] = true;
      return to_explore.push({x, y});
    }
  };
  while (n = to_explore.shift()) {
    ok = f(n.x, n.y, hmm);
    if (ok) {
      hmm(n.x + 1, n.y);
      hmm(n.x - 1, n.y);
      hmm(n.x, n.y + 1);
      hmm(n.x, n.y - 1);
    }
  }
};

parseXY = function(k) {
  var x, y;
  [x, y] = k.split(/,/);
  return {
    x: parseInt(x),
    y: parseInt(y)
  };
};

sign = function(x) {
  if (x > 0) {
    return 1;
  } else if (x < 0) {
    return -1;
  } else {
    return 0;
  }
};

Simulator = (function() {
  class Simulator {
    constructor(grid) {
      this.setGrid(grid);
    }

    set(x, y, v) {
      var k;
      k = `${x},${y}`;
      this.engines = null;
      if (v != null) {
        this.grid[k] = v;
        return this.delta.changed[k] = v;
      } else {
        delete this.grid[k];
        return this.delta.changed[k] = null;
      }
    }

    get(x, y) {
      return this.grid[`${x},${y}`];
    }

    getGrid() {
      return this.grid;
    }

    findEngines() {
      var e, engineGrid, k, ref, size, v, x, y;
      if (this.engines) {
        return;
      }
      this.engines = [];
      engineGrid = {};
      ref = this.grid;
      for (k in ref) {
        v = ref[k];
        if (!((v === 'positive' || v === 'negative') && !engineGrid[k])) {
          continue;
        }
        ({x, y} = parseXY(k));
        e = {
          grid: {},
          pressure: 0,
          root: {x, y}
        };
        size = 0;
        fill({x, y}, (x, y) => {
          k = `${x},${y}`;
          if (this.grid[k] === v) {
            size++;
            engineGrid[k] = e;
            e.grid[k] = true;
            return true;
          } else {
            return false;
          }
        });
        e.pressure = v === 'positive' ? size : -size;
        this.engines.push(e);
      }
    }

    setGrid(grid) {
      this.grid = grid || {};
      delete this.grid.tw;
      delete this.grid.th;
      this.engines = null;
      // Delta bankruptcy.
      return this.delta = {
        changed: {},
        sound: {}
      };
    }

    tryMove(points, dx, dy) {
      var ddx, ddy, i, isMe, j, l, len, len1, len2, len3, m, moved, p, shuttle, x, y;
      if (dx && dy) {
        throw new Error('one at a time, fellas');
      }
      if (!(dx || dy)) {
        return;
      }
      isMe = function(qx, qy) {
        var i, len, x, y;
        for (i = 0, len = points.length; i < len; i++) {
          ({x, y} = points[i]);
          if (x === qx && y === qy) {
            return true;
          }
        }
        return false;
      };
      if (this.held) {
        for (i = 0, len = points.length; i < len; i++) {
          ({x, y} = points[i]);
          if (this.held.x === x && this.held.y === y) {
            return false;
          }
        }
      }
      moved = false;
      while (dx || dy) {
        ddx = sign(dx);
        ddy = sign(dy);
        for (j = 0, len1 = points.length; j < len1; j++) {
          ({x, y} = points[j]);
          if (!isMe(x + ddx, y + ddy)) {
            if (this.get(x + ddx, y + ddy) !== 'nothing') {
              return moved;
            }
          }
        }
        shuttle = {};
        for (l = 0, len2 = points.length; l < len2; l++) {
          ({x, y} = points[l]);
          shuttle[`${x},${y}`] = this.get(x, y);
          this.set(x, y, 'nothing');
        }
        for (m = 0, len3 = points.length; m < len3; m++) {
          p = points[m];
          ({x, y} = p);
          this.set(x + ddx, y + ddy, shuttle[`${x},${y}`]);
          p.x += ddx;
          p.y += ddy;
        }
        dx -= ddx;
        dy -= ddy;
        moved = true;
      }
      return moved;
    }

    getPressure() {
      var e, i, len, pressure, ref;
      this.findEngines();
      pressure = {};
      ref = this.engines;
      for (i = 0, len = ref.length; i < len; i++) {
        e = ref[i];
        fill(e.root, (x, y, hmm) => {
          var _x, _y, c, cell, dx, dy, j, k, len1, ref1, ref2;
          k = `${x},${y}`;
          cell = this.grid[k];
          if (e.grid[k] || (cell === 'nothing' || cell === 'thinshuttle' || cell === 'thinsolid')) {
            pressure[`${x},${y}`] = ((ref1 = pressure[`${x},${y}`]) != null ? ref1 : 0) + e.pressure;
            // Propogate pressure through bridges
            for (j = 0, len1 = cardinal_dirs.length; j < len1; j++) {
              [dx, dy] = cardinal_dirs[j];
              _x = x + dx;
              _y = y + dy;
              if (this.get(_x, _y) === 'bridge') {
                while ((c = this.get(_x, _y)) === 'bridge') {
                  pressure[`${_x},${_y}`] = ((ref2 = pressure[`${_x},${_y}`]) != null ? ref2 : 0) + e.pressure;
                  _x += dx;
                  _y += dy;
                }
                if (c === 'nothing' || c === 'thinshuttle' || c === 'thinsolid') {
                  hmm(_x, _y);
                }
              }
            }
            return true;
          }
          return false;
        });
      }
      return pressure;
    }

    step() {
      var dx, dy, e, force, getShuttle, i, j, l, len, len1, len2, movedX, movedY, points, ref, ref1, shuttleMap, shuttles, thisDelta, x, y;
      shuttleMap = {};
      shuttles = [];
      getShuttle = (x, y) => {
        var ref, s;
        if ((ref = this.get(x, y)) !== 'shuttle') {
          return null;
        }
        s = shuttleMap[`${x},${y}`];
        if (s) {
          return s;
        }
        shuttles.push((s = {
          points: [],
          force: {
            x: 0,
            y: 0
          }
        }));
        // Flood fill the shuttle
        fill({x, y}, (x, y) => {
          var ref1;
          if ((ref1 = this.get(x, y)) === 'shuttle' || ref1 === 'thinshuttle') {
            shuttleMap[`${x},${y}`] = s;
            s.points.push({x, y});
            return true;
          } else {
            return false;
          }
        });
        return s;
      };
      // Populate the shuttles list with all shuttles. Needed because of gravity
      //for k,v of @grid
      //  {x,y} = parseXY k
      //  getShuttle x, y
      this.findEngines();
      ref = this.engines;
      for (i = 0, len = ref.length; i < len; i++) {
        e = ref[i];
        fill(e.root, (x, y, hmm) => {
          var _x, _y, c, cell, dx, dy, j, k, len1, s;
          k = `${x},${y}`;
          cell = this.grid[k];
          if (e.grid[k] || (cell === 'nothing' || cell === 'thinshuttle' || cell === 'thinsolid')) {
            for (j = 0, len1 = cardinal_dirs.length; j < len1; j++) {
              [dx, dy] = cardinal_dirs[j];
              _x = x + dx;
              _y = y + dy;
              if ((s = getShuttle(_x, _y))) {
                s.force.x += dx * e.pressure;
                s.force.y += dy * e.pressure;
              } else if (this.get(_x, _y) === 'bridge') {
                _x += dx;
                _y += dy;
                while ((c = this.get(_x, _y)) === 'bridge') {
                  _x += dx;
                  _y += dy;
                }
                
                // And now its not a bridge...
                if ((s = getShuttle(_x, _y))) {
                  s.force.x += dx * e.pressure;
                  s.force.y += dy * e.pressure;
                } else if (c === 'nothing' || c === 'thinshuttle' || c === 'thinsolid') {
                  hmm(_x, _y);
                }
              }
            }
            //pressure[[x,y]] = (pressure[[x,y]] ? 0) + direction
            return true;
          } else {
            return false;
          }
        });
      }
//console.log shuttles, @engines
      for (j = 0, len1 = shuttles.length; j < len1; j++) {
        ({points, force} = shuttles[j]);
        movedY = this.tryMove(points, 0, force.y); // + 1
        dy = movedY ? sign(force.y) : 0;
        if (!movedY) {
          movedX = this.tryMove(points, force.x, 0);
          dx = movedX ? sign(force.x) : 0;
        } else {
          dx = 0;
        }
        if (dx || dy) {
          for (l = 0, len2 = points.length; l < len2; l++) {
            ({x, y} = points[l]);
            //console.log x+2*dx, y+2*dy, @get(x+2*dx, y+2*dy)
            if ((ref1 = this.get(x + 2 * dx, y + 2 * dy)) === (void 0)) {
              this.delta.sound[`${x},${y}`] = true;
            }
          }
        }
      }
      thisDelta = this.delta;
      this.delta = {
        changed: {},
        sound: {}
      };
      return thisDelta;
    }

    holdShuttle({x, y}) {
      return this.held = {x, y};
    }

    releaseShuttle() {
      return this.held = null;
    }

    // ***** Drawing *****
    boundingBox() {
      var bottom, k, left, ref, right, top, v, x, y;
      // calculate the bounding box
      top = left = bottom = right = null;
      ref = this.grid;
      for (k in ref) {
        v = ref[k];
        ({x, y} = parseXY(k));
        if (left === null || x < left) {
          left = x;
        }
        if (right === null || x >= right) {
          right = x + 1;
        }
        if (top === null || y < top) {
          top = y;
        }
        if (bottom === null || y >= bottom) {
          bottom = y + 1;
        }
      }
      return {top, left, bottom, right};
    }
  };

  return Simulator;

}).call(this);

// Exported for convenience.
Simulator.parseXY = parseXY;

if (typeof module !== 'undefined') {
  module.exports = Simulator;
} else {
  this.Simulator = Simulator;
}
